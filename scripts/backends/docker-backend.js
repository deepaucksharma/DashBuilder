/**
 * Docker Backend for NRDOT Control Loop
 * Implements control loop functionality for Docker deployments
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

const { info, warn, error } = require('../../lib/common/logging');

/**
 * Initialize Docker Backend
 * @param {Object} profile - The profile configuration
 * @returns {Object} - The backend client
 */
function createDockerBackend(profile) {
  // Container names
  const nrdotContainer = process.env.NRDOT_CONTAINER || 'nrdot-complete';
  const otelContainer = process.env.OTEL_CONTAINER || 'nrdot-otel';
  
  return {
    /**
     * Collect metrics data from Docker containers
     */
    async collectMetrics() {
      info('Collecting metrics from Docker containers...');
      
      try {
        // Check if containers are running
        const { stdout: containerStatus } = await execAsync(
          `docker ps --filter "name=${nrdotContainer}" --format "{{.Status}}"`
        );
        
        if (!containerStatus.includes('Up')) {
          error(`Container ${nrdotContainer} is not running`);
          return [];
        }
        
        // Get metrics from container's prometheus endpoint
        const { stdout: metricsOutput } = await execAsync(
          `docker exec ${nrdotContainer} curl -s localhost:8888/metrics`
        );
        
        // Parse prometheus metrics format
        const metrics = parsePrometheusMetrics(metricsOutput);
        info(`Collected ${metrics.length} metrics from ${nrdotContainer}`);
        
        return metrics;
      } catch (err) {
        error(`Failed to collect metrics from Docker: ${err.message}`);
        return [];
      }
    },
    
    /**
     * Analyze the current state
     * @param {Array} metrics - Collected metrics
     */
    async analyzeState(metrics) {
      info('Analyzing current state...');
      
      // Calculate current metrics coverage
      const uniqueMetrics = new Set(metrics.map(m => m.name));
      const coverage = metrics.length > 0 ? uniqueMetrics.size / metrics.length * 100 : 0;
      
      // Calculate cost factors
      const costFactor = metrics.length / 1000; // Simplified cost calculation
      
      return {
        metricsCount: metrics.length,
        uniqueMetricsCount: uniqueMetrics.size,
        currentCoverage: coverage,
        costFactor,
        timestamp: new Date().toISOString(),
        profile: {
          name: profile.name || 'unknown',
          targetCoverage: profile.targetCoverage,
          costReductionTarget: profile.costReductionTarget,
          filterAggressiveness: profile.filterAggressiveness,
          samplingRate: profile.samplingRate
        }
      };
    },
    
    /**
     * Calculate necessary adjustments
     * @param {Object} analysis - Analysis results
     */
    async calculateAdjustments(analysis) {
      info('Calculating adjustments...');
      
      const { currentCoverage, costFactor, profile } = analysis;
      const { targetCoverage, costReductionTarget } = profile;
      
      // Calculate coverage gap
      const coverageGap = targetCoverage - currentCoverage;
      
      // Calculate cost reduction needed
      const currentCost = costFactor * 100; // Simplified cost calculation
      const targetCost = currentCost * (1 - costReductionTarget / 100);
      const costReductionGap = currentCost - targetCost;
      
      return {
        coverageGap,
        costReductionGap,
        recommendations: {
          increaseSampling: coverageGap > 5,
          reduceSampling: coverageGap < -5,
          increaseFiltering: costReductionGap > 0,
          reduceFiltering: costReductionGap < 0
        },
        suggestedSamplingRate: calculateSamplingRate(profile.samplingRate, coverageGap),
        suggestedFilterAggressiveness: calculateFilterAggressiveness(
          profile.filterAggressiveness, costReductionGap
        )
      };
    },
    
    /**
     * Apply adjustments to the Docker containers
     * @param {Object} adjustments - Calculated adjustments
     */
    async applyAdjustments(adjustments) {
      info('Applying adjustments to Docker containers...');
      
      const { 
        suggestedSamplingRate, 
        suggestedFilterAggressiveness, 
        recommendations 
      } = adjustments;
      
      try {
        // Create updated configuration
        const updatedConfig = {
          samplingRate: suggestedSamplingRate,
          filterAggressiveness: suggestedFilterAggressiveness,
          timestamp: new Date().toISOString()
        };
        
        // Convert to YAML for container consumption
        const configYaml = 
`# Generated by control-loop.js
samplingRate: ${suggestedSamplingRate.toFixed(2)}
filterAggressiveness: ${suggestedFilterAggressiveness.toFixed(2)}
timestamp: "${new Date().toISOString()}"
`;
        
        // Write config to container
        await execAsync(
          `docker exec ${nrdotContainer} bash -c 'echo "${configYaml}" > /etc/nrdot-plus/control-loop-config.yaml'`
        );
        
        // Reload configuration
        await execAsync(
          `docker exec ${nrdotContainer} supervisorctl reload`
        );
        
        info(`Applied adjustments: sampling=${suggestedSamplingRate.toFixed(2)}, filtering=${suggestedFilterAggressiveness.toFixed(2)}`);
        return true;
      } catch (err) {
        error(`Failed to apply adjustments: ${err.message}`);
        return false;
      }
    },
    
    /**
     * Report status of control loop
     */
    async reportStatus() {
      info('Reporting status...');
      
      try {
        // Get container stats
        const { stdout: containerStats } = await execAsync(
          `docker stats ${nrdotContainer} --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}"`
        );
        
        const [cpuUsage, memUsage] = containerStats.split('|');
        
        // Create status report
        const statusReport = {
          timestamp: new Date().toISOString(),
          version: '2.0.0',
          mode: 'docker',
          profile: profile.name || 'unknown',
          container: {
            name: nrdotContainer,
            status: 'running',
            cpu: cpuUsage.trim(),
            memory: memUsage.trim()
          },
          healthStatus: 'healthy'
        };
        
        // Write status to container
        const statusJson = JSON.stringify(statusReport, null, 2);
        await execAsync(
          `docker exec ${nrdotContainer} bash -c 'echo '${statusJson}' > /var/lib/nrdot-plus/status-report.json'`
        );
        
        info('Status report generated successfully');
        return statusReport;
      } catch (err) {
        error(`Failed to report status: ${err.message}`);
        return { error: err.message };
      }
    },
    
    /**
     * Clean up resources
     */
    async cleanup() {
      info('Cleaning up Docker backend resources...');
      // No special cleanup needed for Docker backend
      return true;
    }
  };
}

/**
 * Parse Prometheus metrics format into structured data
 * @param {string} metricsText - Raw prometheus metrics
 * @returns {Array} - Structured metrics
 */
function parsePrometheusMetrics(metricsText) {
  const metrics = [];
  const lines = metricsText.split('\n');
  
  let currentMetric = null;
  
  for (const line of lines) {
    // Skip comments and empty lines
    if (line.startsWith('#') || line.trim() === '') {
      continue;
    }
    
    // Parse metric line
    const parts = line.split(' ');
    if (parts.length >= 2) {
      const metricWithLabels = parts[0];
      const value = parseFloat(parts[1]);
      
      // Extract metric name and labels
      const labelsMatch = metricWithLabels.match(/(.*){(.*)}/);
      let name, labels = {};
      
      if (labelsMatch) {
        name = labelsMatch[1];
        const labelParts = labelsMatch[2].split(',');
        
        for (const labelPart of labelParts) {
          const [key, value] = labelPart.split('=');
          if (key && value) {
            // Remove quotes from value
            labels[key] = value.replace(/"/g, '');
          }
        }
      } else {
        name = metricWithLabels;
      }
      
      metrics.push({
        name,
        value,
        labels,
        timestamp: Date.now()
      });
    }
  }
  
  return metrics;
}

/**
 * Calculate new sampling rate based on coverage gap
 */
function calculateSamplingRate(currentRate, coverageGap) {
  // Increase/decrease sampling rate based on coverage gap
  // Ensure sampling rate stays between 0.1 and 1.0
  let newRate = currentRate + (coverageGap / 100);
  return Math.max(0.1, Math.min(1.0, newRate));
}

/**
 * Calculate new filter aggressiveness based on cost reduction gap
 */
function calculateFilterAggressiveness(currentValue, costReductionGap) {
  // Increase/decrease filter aggressiveness based on cost reduction gap
  // Ensure value stays between 0.0 and 1.0
  let newValue = currentValue + (costReductionGap / 1000);
  return Math.max(0.0, Math.min(1.0, newValue));
}

module.exports = createDockerBackend;
