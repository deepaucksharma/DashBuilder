# Advanced EWMA Processor with Ring-based Experimentation
# This configuration enables EWMA only for specific rings (treatment group)

metricstransform/ewma_experiment:
  error_mode: ignore
  log_statements: true
  metric_statements:
    # Apply EWMA only to treatment rings (2, 3) for A/B testing
    - context: metric
      statements:
        # Check if this host is in the treatment group
        - set(cache["is_treatment"], true) where resource.attributes["nrdot.ring"] == "2" or resource.attributes["nrdot.ring"] == "3"
        - set(cache["is_treatment"], false) where cache["is_treatment"] == nil
        
        # Only apply EWMA to treatment group
        - set(cache["apply_ewma"], true) where cache["is_treatment"] == true and resource.attributes["process.importance_float"] > 0.0
        
        # CPU EWMA for treatment group only
        - set(cache["process_key"], Concat([resource.attributes["host.name"], ":", resource.attributes["process.pid"], ":", resource.attributes["process.executable.name"]], "")) where name == "process.cpu.time" and cache["apply_ewma"] == true
        
        # Initialize with configurable alpha from experiment config
        - set(cache["alpha"], 0.2) where cache["apply_ewma"] == true
        
        # Store baseline (first observation) for comparison
        - set(cache["cpu_baseline"], value) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_baseline"] == nil
        
        # Initialize EWMA
        - set(cache["ewma_cpu"], value) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["ewma_cpu"] == nil
        
        # Calculate EWMA with experiment alpha
        - set(cache["ewma_cpu"], (cache["alpha"] * value + (1 - cache["alpha"]) * cache["ewma_cpu"])) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["ewma_cpu"] != nil
        
        # Calculate multiple deviation metrics for analysis
        - set(cache["cpu_deviation_pct"], Abs(value - cache["ewma_cpu"]) / cache["ewma_cpu"] * 100) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["ewma_cpu"] > 0
        - set(cache["cpu_deviation_stddev"], Abs(value - cache["ewma_cpu"]) / Sqrt(cache["ewma_cpu"])) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["ewma_cpu"] > 0
        
        # Multi-threshold anomaly detection
        - set(resource.attributes["process.cpu.anomaly_level"], "severe") where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] > 100
        - set(resource.attributes["process.cpu.anomaly_level"], "high") where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] > 75 and cache["cpu_deviation_pct"] <= 100
        - set(resource.attributes["process.cpu.anomaly_level"], "medium") where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] > 50 and cache["cpu_deviation_pct"] <= 75
        - set(resource.attributes["process.cpu.anomaly_level"], "low") where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] > 25 and cache["cpu_deviation_pct"] <= 50
        - set(resource.attributes["process.cpu.anomaly_level"], "normal") where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] <= 25
        
        # Set binary anomaly flag for compatibility
        - set(resource.attributes["process.cpu.is_anomaly"], true) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] > 50
        - set(resource.attributes["process.cpu.is_anomaly"], false) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] <= 50
        
        # Add experiment metadata
        - set(resource.attributes["experiment.ewma.enabled"], true) where cache["apply_ewma"] == true
        - set(resource.attributes["experiment.ewma.alpha"], cache["alpha"]) where cache["apply_ewma"] == true
        - set(resource.attributes["experiment.group"], "treatment") where cache["is_treatment"] == true
        - set(resource.attributes["experiment.group"], "control") where cache["is_treatment"] == false
        
        # Store detailed metrics for analysis
        - set(resource.attributes["process.cpu.ewma"], Round(cache["ewma_cpu"], 2)) where name == "process.cpu.time" and cache["apply_ewma"] == true
        - set(resource.attributes["process.cpu.deviation_pct"], Round(cache["cpu_deviation_pct"], 1)) where name == "process.cpu.time" and cache["apply_ewma"] == true and cache["cpu_deviation_pct"] != nil
        - set(resource.attributes["process.cpu.baseline"], cache["cpu_baseline"]) where name == "process.cpu.time" and cache["apply_ewma"] == true

    # Memory EWMA with experiment support
    - context: metric
      statements:
        # Apply same experiment logic to memory
        - set(cache["apply_ewma"], true) where (resource.attributes["nrdot.ring"] == "2" or resource.attributes["nrdot.ring"] == "3") and resource.attributes["process.importance_float"] > 0.0
        
        # Memory EWMA calculations (similar pattern)
        - set(cache["ewma_memory"], value) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["ewma_memory"] == nil
        - set(cache["ewma_memory"], (0.2 * value + 0.8 * cache["ewma_memory"])) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["ewma_memory"] != nil
        
        # Memory anomaly detection with lower threshold (memory is more stable)
        - set(cache["memory_deviation_pct"], Abs(value - cache["ewma_memory"]) / cache["ewma_memory"] * 100) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["ewma_memory"] > 0
        - set(resource.attributes["process.memory.is_anomaly"], true) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["memory_deviation_pct"] > 40
        - set(resource.attributes["process.memory.is_anomaly"], false) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["memory_deviation_pct"] <= 40
        
        # Store memory EWMA metrics
        - set(resource.attributes["process.memory.ewma"], Round(cache["ewma_memory"], 0)) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true
        - set(resource.attributes["process.memory.deviation_pct"], Round(cache["memory_deviation_pct"], 1)) where name == "process.memory.physical_usage" and cache["apply_ewma"] == true and cache["memory_deviation_pct"] != nil

    # Overall anomaly scoring with experiment awareness
    - context: metric
      statements:
        # Calculate composite anomaly score for treatment group
        - set(cache["anomaly_dimensions"], 0) where cache["apply_ewma"] == true
        - set(cache["anomaly_dimensions"], cache["anomaly_dimensions"] + 1) where resource.attributes["process.cpu.is_anomaly"] == true
        - set(cache["anomaly_dimensions"], cache["anomaly_dimensions"] + 1) where resource.attributes["process.memory.is_anomaly"] == true
        - set(cache["anomaly_dimensions"], cache["anomaly_dimensions"] + 1) where resource.attributes["process.io.is_anomaly"] == true
        
        # Set anomaly score (0-1)
        - set(resource.attributes["process.anomaly_score"], cache["anomaly_dimensions"] / 3.0) where cache["apply_ewma"] == true and cache["anomaly_dimensions"] > 0
        
        # Set overall anomaly flag
        - set(resource.attributes["process.is_anomaly"], true) where cache["apply_ewma"] == true and cache["anomaly_dimensions"] > 0
        - set(resource.attributes["process.is_anomaly"], false) where cache["apply_ewma"] == true and cache["anomaly_dimensions"] == 0
        
        # Add anomaly timestamp for tracking
        - set(resource.attributes["process.anomaly_detected_at"], Now()) where resource.attributes["process.is_anomaly"] == true and resource.attributes["process.anomaly_detected_at"] == nil