#!/usr/bin/env node

/**
 * NRDOT Experiment Runner with New Relic Verification
 * Runs multiple configurations simultaneously and verifies data ingestion
 */

const { exec, spawn } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');

const execAsync = promisify(exec);

// Configuration profiles to test
const PROFILES = ['baseline', 'conservative', 'balanced', 'aggressive'];

// Experiment configuration
const experimentConfig = {
  duration: parseInt(process.env.EXPERIMENT_DURATION || '300'), // 5 minutes default
  checkInterval: 30, // Check every 30 seconds
  warmupTime: 60, // Wait 60 seconds for services to stabilize
  experimentId: process.env.EXPERIMENT_ID || `exp-${Date.now()}`,
  experimentName: process.env.EXPERIMENT_NAME || 'nrdot-multi-profile-test',
  accountId: process.env.NEW_RELIC_ACCOUNT_ID || '33',
  apiKey: process.env.NEW_RELIC_API_KEY
};

// Container names for each profile
const getContainerName = (profile) => `nrdot-${profile}`;

// Service configuration for each profile
const createServiceConfig = (profile, index) => ({
  name: `otel-collector-${profile}`,
  container_name: getContainerName(profile),
  image: 'otel/opentelemetry-collector-contrib:latest',
  command: ['--config=/etc/otel-collector.yaml'],
  volumes: [
    `./configs/collector-${profile}.yaml:/etc/otel-collector.yaml:ro`,
    './configs/collector-profiles:/etc/collector-profiles:ro',
    '/var/run/docker.sock:/var/run/docker.sock:ro',
    '/proc:/host/proc:ro',
    '/sys:/host/sys:ro'
  ],
  environment: {
    NEW_RELIC_LICENSE_KEY: '${NEW_RELIC_LICENSE_KEY}',
    OTEL_EXPORTER_OTLP_ENDPOINT: '${OTEL_EXPORTER_OTLP_ENDPOINT:-https://otlp.nr-data.net}',
    NRDOT_PROFILE: profile,
    EXPERIMENT_ID: experimentConfig.experimentId,
    EXPERIMENT_NAME: experimentConfig.experimentName,
    OTEL_SERVICE_NAME: `nrdot-${profile}`,
    OTEL_RESOURCE_ATTRIBUTES: `service.name=nrdot-${profile},nrdot.profile=${profile},experiment.id=${experimentConfig.experimentId}`
  },
  ports: [
    `${4317 + index}:4317`,
    `${4318 + index}:4318`,
    `${8888 + index}:8888`,
    `${13133 + index}:13133`
  ],
  healthcheck: {
    test: ['CMD', 'curl', '-f', `http://localhost:13133/health`],
    interval: '10s',
    timeout: '5s',
    retries: 5
  }
});

// Generate docker-compose file for experiments
async function generateExperimentCompose() {
  const services = {};
  
  PROFILES.forEach((profile, index) => {
    services[`collector-${profile}`] = createServiceConfig(profile, index);
  });
  
  const compose = {
    version: '3.8',
    services,
    networks: {
      default: {
        name: 'nrdot-experiment-network'
      }
    }
  };
  
  const yamlContent = JSON.stringify(compose, null, 2)
    .replace(/"/g, '')
    .replace(/\${([^}]+)}/g, '${$1}');
  
  await fs.writeFile('docker-compose.experiment.yml', 
    `# Auto-generated experiment configuration\n# DO NOT EDIT - Generated by run-nrdot-experiments.js\n\n` + yamlContent
  );
}

// Start experiment containers
async function startExperiment() {
  console.log(chalk.blue.bold('\nðŸš€ Starting NRDOT Multi-Configuration Experiment\n'));
  console.log(chalk.gray(`Experiment ID: ${experimentConfig.experimentId}`));
  console.log(chalk.gray(`Duration: ${experimentConfig.duration}s`));
  console.log(chalk.gray(`Profiles: ${PROFILES.join(', ')}\n`));
  
  // Generate docker-compose file
  await generateExperimentCompose();
  
  // Stop any existing experiment containers
  console.log('Cleaning up previous experiments...');
  await execAsync('docker-compose -f docker-compose.experiment.yml down -v 2>/dev/null || true');
  
  // Start experiment containers
  console.log('Starting experiment containers...');
  await execAsync('docker-compose -f docker-compose.experiment.yml up -d');
  
  // Wait for containers to be healthy
  console.log(`Waiting ${experimentConfig.warmupTime}s for services to stabilize...`);
  await new Promise(resolve => setTimeout(resolve, experimentConfig.warmupTime * 1000));
  
  // Verify all containers are running
  const psResult = await execAsync('docker-compose -f docker-compose.experiment.yml ps --format json');
  const containers = JSON.parse(`[${psResult.stdout.trim().split('\n').join(',')}]`);
  
  const runningContainers = containers.filter(c => c.State === 'running');
  console.log(`\nâœ… ${runningContainers.length}/${PROFILES.length} containers running\n`);
  
  if (runningContainers.length !== PROFILES.length) {
    console.error(chalk.red('Not all containers started successfully!'));
    return false;
  }
  
  return true;
}

// Query New Relic for metrics
async function queryNewRelicMetrics(profile, startTime) {
  const https = require('https');
  
  const nrql = `
    SELECT 
      count(*) as dataPoints,
      uniqueCount(metricName) as uniqueMetrics,
      uniqueCount(entity.name) as entities,
      rate(sum(nrdot.datapoints.reduced), 1 minute) as reductionRate
    FROM Metric 
    WHERE nrdot.profile = '${profile}' 
      AND experiment.id = '${experimentConfig.experimentId}'
    SINCE ${startTime} seconds ago
  `;
  
  const endpoint = `https://insights-api.newrelic.com/v1/accounts/${experimentConfig.accountId}/query?nrql=${encodeURIComponent(nrql)}`;
  
  return new Promise((resolve, reject) => {
    const options = {
      headers: {
        'X-Query-Key': experimentConfig.apiKey,
        'Accept': 'application/json'
      }
    };
    
    https.get(endpoint, options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          resolve(result.results?.[0] || {});
        } catch (error) {
          reject(error);
        }
      });
    }).on('error', reject);
  });
}

// Monitor experiment progress
async function monitorExperiment(startTime) {
  const results = {};
  const checkCount = Math.floor(experimentConfig.duration / experimentConfig.checkInterval);
  
  console.log(chalk.blue('\nðŸ“Š Monitoring Experiment Progress\n'));
  
  for (let i = 0; i < checkCount; i++) {
    const elapsed = (i + 1) * experimentConfig.checkInterval;
    process.stdout.write(`\rElapsed: ${elapsed}s / ${experimentConfig.duration}s`);
    
    // Query metrics for each profile
    for (const profile of PROFILES) {
      try {
        const metrics = await queryNewRelicMetrics(profile, elapsed);
        
        if (!results[profile]) {
          results[profile] = {
            checks: [],
            firstDataPoint: null,
            lastDataPoint: null
          };
        }
        
        results[profile].checks.push({
          timestamp: Date.now(),
          elapsed,
          ...metrics
        });
        
        if (metrics.dataPoints > 0 && !results[profile].firstDataPoint) {
          results[profile].firstDataPoint = elapsed;
        }
        
        if (metrics.dataPoints > 0) {
          results[profile].lastDataPoint = elapsed;
        }
      } catch (error) {
        console.error(`\nError querying ${profile}:`, error.message);
      }
    }
    
    await new Promise(resolve => setTimeout(resolve, experimentConfig.checkInterval * 1000));
  }
  
  console.log('\n\n');
  return results;
}

// Analyze results
async function analyzeResults(results) {
  console.log(chalk.blue.bold('ðŸ“ˆ Experiment Results\n'));
  
  const summary = {};
  
  // Create summary table
  console.log('Profile      | Data Points | Unique Metrics | Time to Data | Reduction Rate');
  console.log('-------------|-------------|----------------|--------------|---------------');
  
  for (const profile of PROFILES) {
    const profileData = results[profile];
    if (!profileData || profileData.checks.length === 0) {
      console.log(`${profile.padEnd(12)} | ${chalk.red('No data')}`);
      continue;
    }
    
    const lastCheck = profileData.checks[profileData.checks.length - 1];
    const avgReductionRate = profileData.checks
      .filter(c => c.reductionRate)
      .reduce((sum, c) => sum + c.reductionRate, 0) / profileData.checks.length;
    
    summary[profile] = {
      totalDataPoints: lastCheck.dataPoints || 0,
      uniqueMetrics: lastCheck.uniqueMetrics || 0,
      timeToFirstData: profileData.firstDataPoint,
      avgReductionRate: avgReductionRate || 0
    };
    
    console.log(
      `${profile.padEnd(12)} | ` +
      `${(lastCheck.dataPoints || 0).toString().padEnd(11)} | ` +
      `${(lastCheck.uniqueMetrics || 0).toString().padEnd(14)} | ` +
      `${profileData.firstDataPoint ? profileData.firstDataPoint + 's' : 'N/A'} | ` +
      `${avgReductionRate.toFixed(2)}`
    );
  }
  
  // Calculate cost reduction compared to baseline
  if (summary.baseline && summary.baseline.totalDataPoints > 0) {
    console.log(chalk.blue('\nðŸ“Š Cost Reduction Analysis\n'));
    
    for (const profile of PROFILES.filter(p => p !== 'baseline')) {
      if (summary[profile]) {
        const reduction = ((summary.baseline.totalDataPoints - summary[profile].totalDataPoints) / 
                          summary.baseline.totalDataPoints * 100).toFixed(2);
        console.log(`${profile}: ${reduction}% reduction vs baseline`);
      }
    }
  }
  
  // Save detailed results
  const resultsPath = path.join('experiment-results', `${experimentConfig.experimentId}.json`);
  await fs.mkdir('experiment-results', { recursive: true });
  await fs.writeFile(resultsPath, JSON.stringify({
    experimentId: experimentConfig.experimentId,
    experimentName: experimentConfig.experimentName,
    startTime: new Date().toISOString(),
    duration: experimentConfig.duration,
    profiles: PROFILES,
    summary,
    details: results
  }, null, 2));
  
  console.log(chalk.gray(`\nDetailed results saved to: ${resultsPath}`));
  
  return summary;
}

// Cleanup experiment
async function cleanupExperiment() {
  console.log(chalk.blue('\nðŸ§¹ Cleaning up experiment...\n'));
  
  // Get container logs before cleanup
  for (const profile of PROFILES) {
    try {
      const logs = await execAsync(`docker logs ${getContainerName(profile)} --tail 50 2>&1`);
      const logPath = path.join('experiment-results', `${experimentConfig.experimentId}-${profile}.log`);
      await fs.writeFile(logPath, logs.stdout + logs.stderr);
    } catch (error) {
      // Container might not exist
    }
  }
  
  // Stop and remove containers
  await execAsync('docker-compose -f docker-compose.experiment.yml down -v');
  
  // Remove generated compose file
  await fs.unlink('docker-compose.experiment.yml').catch(() => {});
}

// Main execution
async function main() {
  try {
    // Validate environment
    if (!experimentConfig.apiKey) {
      console.error(chalk.red('ERROR: NEW_RELIC_API_KEY environment variable is required'));
      process.exit(1);
    }
    
    // Create baseline configurations if they don't exist
    for (const profile of PROFILES) {
      const configPath = `./configs/collector-${profile}.yaml`;
      try {
        await fs.access(configPath);
      } catch {
        // Copy baseline and modify
        const baselineConfig = await fs.readFile('./configs/collector-baseline.yaml', 'utf8');
        const modifiedConfig = baselineConfig.replace(/nrdot\.profile:\s*baseline/g, `nrdot.profile: ${profile}`);
        await fs.writeFile(configPath, modifiedConfig);
      }
    }
    
    // Start experiment
    const started = await startExperiment();
    if (!started) {
      await cleanupExperiment();
      process.exit(1);
    }
    
    // Monitor experiment
    const startTime = Date.now();
    const results = await monitorExperiment(startTime);
    
    // Analyze results
    await analyzeResults(results);
    
    // Verify data in New Relic
    console.log(chalk.blue('\nðŸ” Verifying data in New Relic...\n'));
    const { spawn } = require('child_process');
    const verify = spawn('node', ['scripts/verify-newrelic-data.js', '--compare'], {
      stdio: 'inherit',
      env: { ...process.env, EXPERIMENT_ID: experimentConfig.experimentId }
    });
    
    await new Promise(resolve => verify.on('close', resolve));
    
  } catch (error) {
    console.error(chalk.red('\nExperiment failed:'), error);
    process.exit(1);
  } finally {
    await cleanupExperiment();
  }
}

// Handle termination
process.on('SIGINT', async () => {
  console.log(chalk.yellow('\n\nInterrupted! Cleaning up...'));
  await cleanupExperiment();
  process.exit(0);
});

// Run main
main();